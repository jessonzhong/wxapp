{"title": "微信小程序开发中 var that =this的用法 ", "author": null, "pub_time": null, "content": "在微信小程序开发中，var that =this的声明很常见。举个例子，代码如下！示例代码11  //index.js  \r\n2  Page({  \r\n3   \r\n4   data: {  \r\n5    toastHidden: true,  \r\n6   },  \r\n7   \r\n8   loadData: function () {  \r\n9      var that = this//这里声明了that；将this存在that里面  \r\n10     wx.request({  \r\n11       url: 'test.php',  \r\n12       data: {a: 'a', b: 'b'},  \r\n13       header: {  \r\n14        'content-type': 'application/json'  \r\n15       },  \r\n16       success(res) {  \r\n17           that.setData({ toastHidden: false }) //这里使用了that，这样就可以获取Page({})对象  \r\n18        },  \r\n19      })  \r\n20    }  \r\n21  \r\n22  })在代码中第9行声明了var that =this；第17行使用了that。如果不声明var that =this，且that改成this，代码如下！示例代码21  //index.js  \r\n2   Page({  \r\n3  \r\n4    data: {  \r\n5     toastHidden: true,  \r\n6   },  \r\n7  \r\n8    loadData: function () {  \r\n9      wx.request({  \r\n10      url: 'test.php',  \r\n11      data: {a: 'a', b: 'b'},  \r\n12      header: {  \r\n13       'content-type': 'application/json'  \r\n14      },  \r\n15      success(res) {  \r\n16        this.setData({ toastHidden: false })  \r\n17       },  \r\n18      })  \r\n19   }  \r\n20  \r\n21  })此时运行代码就会报以下错误！从报错中得知setData这个属性读不到，为何读不到？这跟this关键字的作用域有关！this作用域分析：1.在Page({})里面，this关键字指代Page({})整个对象2.因此可以通过this关键字访问或者重新设置Page({})里data的变量3.然而在loadData函数中使用了wx.request({})API这个方法导致在wx.request({})里没办法使用this来获取Page({})对象4.虽然在wx.request({})里没法使用this获取Page({})对象，但是可以在wx.request({})外面先把this存在某个变量中，所以就有了var that =this 这个声明。此时that指代Page({})整个对象，这样子就可以在wx.request({})里使用that访问或者重新设置Page({})里data的变量"}
{"title": "如何处理小程序独立分包的数据共享问题 ", "author": null, "pub_time": null, "content": ""}
{"title": "小程序登录的最优流程 ", "author": null, "pub_time": null, "content": "18年中旬做过一个小程序，当时是通过转跳到一个登录页，然后点击调用 wx.getUserInfo ，然后发现这个api被禁用了(虽然依然可以用)，然后用<!-- 需要使用 button 来授权登录 -->\r\n<button wx:if=\"{{canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\">授权登录</button>\r\n<view wx:else>请升级微信版本</view>\r\n复制代码因为当时刚好需要用户信息，然后这个api有一个 encryptedData 属性可以获取信息。这样的流程本就可以了，但是意外出现了。思维的禁锢当第二次(2020年)需要开发一个新的小程序，于是也用了老代码， 但是出现了个奇怪的问题。 有兴趣的可以看下面的[奇怪的问题]奇怪的问题：因为微信限制无法转跳到登录页，所以想是否应该在首页设置一个弹窗，点击的时候授权。但是因为考虑到可能会被微信拒绝，故在小程序开发者论坛开了一篇文章app无法转跳到登录页面 and 小程序登录的哲学思考随后发现，登录其实并不需要授权弹窗or页面。（如果服务器不需要保存用户信息)流程下面这个图是小程序官方图 点我转跳代码app.js（小程序的入口文件）的完整代码const loginDataKey = 'loginData'\r\n\r\n//app.js\r\nApp({\r\n  onLaunch: function () {\r\n\r\n    const loginData = wx.getStorageSync(loginDataKey)\r\n    console.log('--loginData--')\r\n    console.log(loginData)\r\n    let toLogin = () => {\r\n      console.log('未登录，去登录..')\r\n      wx.showLoading({title: '登录中', icon: 'loading', mask: true})\r\n      wx.login({\r\n        success(res){\r\n          console.log('wx.login res')\r\n          console.log(res)\r\n          let success = () => {\r\n            console.log('登录成功')\r\n            let loginResponse = {\"openid\":\"ooZAbwpdDdaZV_xiamianshi_mashaike\"}\r\n            wx.setStorageSync(loginDataKey, loginResponse)\r\n            wx.hideLoading()\r\n          }\r\n          let fail = () => {\r\n            wx.hideLoading()\r\n            wx.showToast({\r\n              title: '登录失败，请重新打开小程序试试',\r\n              icon: 'none',\r\n              duration: 1e8\r\n            })\r\n          }\r\n          // TODO 发起网络请求\r\n          // 延时模拟请求登录成功\r\n          setTimeout(success, 500)\r\n        },\r\n        fail(err){\r\n          console.log(err)\r\n          wx.hideLoading()\r\n          wx.showToast({\r\n            title: '登录失败，请重新打开小程序试试',\r\n            icon: 'none',\r\n            duration: 1e8\r\n          })\r\n        }\r\n      })\r\n    }\r\n    // 未登录，去登录\r\n    if(!loginData){\r\n      toLogin()\r\n    // 已登录，但是微信session_key过期\r\n    }else{\r\n      wx.checkSession({\r\n        success () {\r\n          //session_key 未过期，并且在本生命周期一直有效\r\n          console.log('session_key 未过期')\r\n        },\r\n        fail () {\r\n          // session_key 已经失效，需要重新执行登录流程\r\n          console.log('session_key 已经失效，需要重新执行登录流程, 重新登录中')\r\n          toLogin()\r\n        }\r\n      })\r\n    }\r\n\r\n  },\r\n  globalData: {\r\n    userInfo: null\r\n  }\r\n})\r\n复制代码流程如下根据本地储存判断是否登录已登录判断是否失效失效或者未登录去登录登录展示toast拿到信息存储 关闭toast核心wx.login拿到code然后把code通过 auth.code2Session 获取openid和unionid等。这是我通过 auth.code2Session 拿到openid的截图（因为这个是测试号，所以没有unionid）【unionid】是拿来和其他平台打通账号的关键，如果只有一个小程序，都可以不需要这个。效果\r\n\r\n其他\r\n纯展示用户头像昵称等\r\n<open-data type=\"userAvatarUrl\"></open-data>\r\n<open-data type=\"userNickName\"></open-data>\r\n复制代码查看open-data文档\r\n--完--"}
{"title": "微信小程序 动态加载swiper时不显示的问题（爬坑） ", "author": null, "pub_time": null, "content": "问题一报错信息TypeError: Cannot read property '$$' of undefined\r\n    at HTMLElement._attached.wx.getPlatform._touchstartHandlerForDevtools解决方法：因为小程序会保留上一次滑动swiper时候的current，所以会出现上次滑动到的current在这次的数据中不存在问题，所以，每次动态加载swiper-item前，需要设置swiper的current属性为0问题二swiper 的current每次设置了0，但是还是不显示 swiper，检查元素是存在的，并且current = -1<swiper current='-1'><swiper>解决方法，动态设置swiper-item的数据时，还需设置current = 0，并且current和swiperList不能在一个this.setData中设置，要先setData swiperList 然后在setData current我是这样写的：this.setData({\r\n  swiperItem: list\r\n},()=>{\r\n  this.setData({\r\n    current: 0\r\n  })\r\n})\r\n//在每次给swiper赋值之后在它的回调中在赋值current之后没有问题成功解决，希望对你有所帮助。"}
{"title": "京东购物小程序cookie方案实践 ", "author": null, "pub_time": null, "content": "早期为了解决“会话保持”的需求，社区中出现了「cookie方案」并最终成为W3C标准：当某个网站登录成功后，客户端（浏览器）收到一个cookie标识（文本）并保存下来，在后续请求中会自动带上这个字段，由此Web后台可以判断是否同一个用户，从而使“会话”得以延续。微信小程序没有像浏览器一样内置实现了cookie方案，需要开发者自行模拟，而原先京东购物小程序及京喜小程序（现微信一级购物入口）是从微信及手Q购物H5中迁移迭代出来的，也就是说我们不仅要在小程序中模拟一套cookie方案，并且要保持和原业务对cookie处理逻辑的一致，为此我们将实现方向确定为“基于小程序开放能力，和浏览器保持一致”。微信小程序开放了 数据缓存 Storage 和 网络 Network 这两种能力，通过这两套API，我们可以自行DIY一个cookie方案。PS：本文所有代码及使用示例都可以 在这里 找到，阅读本文时配合实践，效果更佳。二、浏览器中的cookie为了保持后端对cookie的处理逻辑和原来的H5一致，小程序的实现需要往浏览器看齐。所以模拟小程序的cookie前，先看看浏览器的cookie机制，主要有以下几个部分：本地存储：浏览器会在本地分配一块空间，存储cookie请求携带：每次发起请求，都会从本地取出cookie并追加在请求头上响应设置：当响应头有Set-Cookie字段时，需要解析并更新过期时间：每个cookie字段有单独的过期时间，并且到期会自动清除读写操作：暴露API给前端JS调用，可进行增删改查操作作用域：路径path、域名domin编码：cookie值，在网络传输需要encode，建议存储也一样其它：HttpOnly、Secure、SameSite在浏览器的 DevTools 中，可以看到当前站点下的Cookie明细：三、小程序中的cookie实现方案设计在小程序中模拟Cookie，主要涉及五个部分：其中我们会重点关注 「Cookie基础库」 的实现，另外也会给出「Request基础库」的封装示例。本地存储小程序提供了 「数据缓存 Storage API」（可以理解为Web规范中的 LocalStorage ），支持存储“原生类型、Date、及能够通过JSON.stringify序列化的对象”。我们可以利用这些API，在Storage中新开一个 cookies 字段进行存储：// 存：\r\nwx.setStorageSync('cookies', cookies)\r\n// 取：\r\nwx.getStorageSync('cookies')\r\n复制代码其中 cookies 的「存储结构」如下：// cookies = \r\n{\r\n    cookie1: { // “最小cookie单元” ==> cookieItem\r\n        name: 'cookie1', // cookie名\r\n        value: 'xxx',    // cookie值\r\n        expires: 'Fri, 17 Jan 2020 08:49:41 GMT' // 过期时间，使用GMT（格林威治标准时间）格式\r\n    }\r\n},\r\n复制代码上面的 cookie1 便是一个“最小cookie单元 cookieItem ”，包含了3个字段（name、value、expires），是本文中定义的「标准cookie格式」，也是cookie操作的基本单元。打开【微信开发工具】的 Storage 选项卡，可以查看本地存储的情况：读写操作这部分主要作为“公共基础库“的角色，为外部业务提供增删改查cookie的API。1. 获取cookie———— getCookie()步骤：从Storage中取出完整cookies ==> 取出指定name的cookie项 ==> 校验有效期 ==> 返回值value实现如下：function getCookie(name = '') {\r\n    let cookies = wx.getStorageSync('cookies') // try/catch 略过\r\n    let { value, expires } = cookies[name] || {}\r\n\r\n    return (name && expires && !isExpired(expires)) ? decodeURIComponent(cookieItem.value) : ''\r\n}\r\n复制代码2. 设置cookie———— setCookie()步骤：从Storage中取出完整cookies ==> 解析入参 ==> 覆盖更新 ==> 同步到本地Storage首先看下本API设计需求：设置单个/多个cookie直接传值/传cookieItem（Object）时间格式maxAge/expires调用示例如下：setCookie({\r\n    cookie1: 12345,\r\n    cookie2: '12345'\r\n})\r\n\r\nsetCookie({\r\n    cookie1: {\r\n        value: 12345,\r\n        maxAge: 3600 * 24  // 自定义有效期（这里示例是24小时）\r\n    },\r\n    cookie2: {\r\n        value: '12345',\r\n        expires: 'Wed, 21 Oct 2015 07:28:00 GMT' // 标准GMT格式\r\n    }\r\n})\r\n复制代码这里可对入参遍历，而cookie子项无论直接传值value还是传了详细object，都尽量的获取 name/value/expires/maxAge ，传给格式化函数转为标准的 cookieItem ：function setCookie(cookiesParam) {\r\n    let oldCookies = wx.getStorageSync('cookies') // try/catch 略过\r\n    let newCookies = {} // 由 cookiesParam 转化为标准格式后的cookies\r\n\r\n    for (let name in cookiesParam) {\r\n        if (isObject(cookiesParam[name])) { // 传入是Object格式\r\n            let { value, expires, maxAge } = cookiesParam[name]\r\n            // 转换为标准cookie格式（cookieItem）\r\n            newCookies[name] = getStandardCookieItem({ name, value, expires, maxAge })\r\n        } else {\r\n            newCookies[name] = getStandardCookieItem({ name, value: cookiesParam[name] })\r\n        }\r\n    }\r\n\r\n    // 同步到本地Storage\r\n    saveCookiesToStorage(Object.assign({}, oldCookies, newCookies))\r\n}\r\n复制代码3. 删除cookie———— removeCookie()步骤：从Storage中取出完整cookies ==> 删除指定的cookie项 ==> 同步到本地Storagefunction removeCookie(cookieName) {\r\n    let cookies = wx.getStorageSync('cookies') // try/catch 略过\r\n\r\n    delete cookies[cookieName]\r\n\r\n    saveCookiesToStorage(Object.assign({}, cookies))\r\n}\r\n复制代码四、Cookie 在网络中的传递本节主要简单实现设计图中的【Request基础库】部分如上图所示，Cookie在网络中的传输主要有四个过程：Set-Cookie\r\nCookie\r\nCookie\r\n以下是对一个请求的抓包示例：在小程序中，请求发起有两种方式： HTTP 和 WebSocket ，这里以HTTP为例，先对请求api进行「封装」：function requestPro({ url, data, header, method = 'GET' }) {\r\n    return new Promise((resolve, reject) => {\r\n        wx.request({\r\n            url,\r\n            data,\r\n            header: Object.assign({}, { 'Cookie': CookieLib.getCookiesStr() }, header), // 请求头————带上Cookie\r\n            success (res) {\r\n              let { data : resData, header, statusCode } = res\r\n              let setCookieStr = header['Set-Cookie'] || header['set-cookie'] || ''\r\n\r\n              CookieLib.setCookieFromHeader(setCookieStr) // 响应头————解析Set-Cookie\r\n              resolve(resData)\r\n            },\r\n            fail (err) {\r\n                reject(err)\r\n            }\r\n          })\r\n    })\r\n}\r\n复制代码如上代码所示，Cookie在前端侧请求模块中的处理主要有3点：1. 请求携带步骤：（每次发请求前）从Storage中取出完整cookies ==> 转化为HTTP规范的请求头Cookie格式 ==> 设置到 Request Header 中上面代码中的 getCookiesStr() 直接取cookies拼接即可，返回示例： cookie1=xxx;cookie2=yyy 。2. 响应设置步骤：（每次收到响应后）解析 Response Header 的 Set-Cookie 字段 ==> 转为标准Cookie格式 ==> setCookie()这里处理 Set-Cookie 内容时，有几个点需要留意： - 最基本的格式： Set-Cookie: <cookie-name>=<cookie-value> - 可能同时包含多个cookie字段，以,分割（但需要排除时间值里的,） - 时间格式：Max-Age/Expires （不区分大小写）具体实现可在文末Demo中找到。3. 编码问题「Cookie值编码方式」是容易产生困惑的地方，目前看到的广泛做法都是使用「URL编码」。但笔者翻阅 RFC6265 发现，原始规范中并没有对编码进行指定，比如在第四章 Server Requirements （服务端）中是这样描述：To maximize compatibility with user agents, servers that wish to store arbitrary data in a cookie-value SHOULD encode that data, for example, using Base64 [RFC4648].\r\n“为了最好的兼容效果，服务端应该对cookie值进行编码，例如使用Base64。”而在第五章 User Agent Requirements （客户端，也就是浏览器），则是“建议以第四章服务端的实现为准”。总之规范并没有指定使用「URL编码」，但基于该编码方案已经深入人心，也就顺其自然成了“默认选择”。那这里也不做例外，浏览器怎么做，咋们小程序也保持一致。在浏览器中，推荐cookie值经过 encode 编码后保存下来，所以直接取到的也是 encode 后的值，所以追加在请求头 Cookie 字段，就不需要 decode 解码了，直接拼接即可（但基础库API的get操作最终需要进行 decode 解码）。而对于响应头 Set-Cookie 的值，我们认为后端已经做了 encode 编码，所以前端不需要处理，直接存进 Storage 即可。五、性能优化（高频读写）前面实现中每次读写cookie都会调用小程序Storage API（而且是同步的），小程序框架会读写到本地Storage。 对于高频场景，可以将cookie在内存中维护一份，读写都直接走「内存层」，有更新才同步到「Storage层」。1. 初始化首先需要在内存中声明一个 _COOKIES （命名自行diy），建议在cookie基础库中声明，便于统一维护。2. 读前面初始化时已经从Storage读取一次cookies，后续getCookie就直接读内存的 _COOKIES 即可。3. 写写操作直接更新内存，间接更新Storage。 如果有高频写场景，可以考虑做个任务队列进行节流。六、单元测试微信官方在2019年5月推出了「小程序自动化 SDK」 miniprogram-automator ，经过半年多的迭代，目前已基本稳定下来。在购物小程序场景试用了一下，cookie相关的用例很快就完成了，简直是开发者的福音：真香！！！实际项目中，对cookie的单元测试可以分为两类：小程序全局范围的cookie验证（比如初始化小程序后，有没有种下版本号、访问行为等关键cookie）cookie基础库API验证（比如get/set/remove等各个API是否正常工作）以验证 setCookie() API为例：it('API验证：setCookie()', async () => {\r\n    await miniProgram.evaluate(() => {\r\n        wx.CookieLib.setCookie({ // 调用API\r\n            cookie1: 12345,\r\n        })\r\n    })\r\n\r\n    let { cookies } = await miniProgram.callWxMethod('getStorageSync', 'cookies')\r\n    expect(cookies['cookie1'].value).toBe(12345) // 期望成功设置cookie1为12345\r\n})\r\n复制代码这里为了方便测试用例调用基础库API，在小程序启动前，把Cookie基础库（CookieLib）挂到了 wx 对象上，实现方式是使用node读写文件的API去【植入代码】：fs.appendFileSync('./your_project/app.js', ''\\n wx.CookieUtil = require(\\'./lib/cookie.js\\');\\n'')\r\n复制代码七、Cookie安全Cookie安全是一个比较大的话题，这里只简单列出和小程序相关的几个点。path、domin、HttpOnly、Secure、SameSite小程序中已经做了一些安全措施，比如只能走HTTPS、合法域名需要管理员到微信后台进行配置、Storage只能由写入它的小程序中访问，等等。 因此 path、domin、HttpOnly、Secure、SameSite 这些字段在小程序环境下的价值没有浏览器环境大，本例中没有使用（懒..），而实际业务场景可以按自身情况决定是否要使用。白名单机制前端维护（大小/数量） 通常浏览器保持的Cookie数据不超过4k，部分浏览器限制同一站点最多cookie数为20个。 如果业务庞大的话，建议在Cookie基础库做一套「白名单」机制，在白名单内才可以写入，以此防止“非法写入”或“内容超大导致信息丢失”的问题。后台维护（网关白名单） 同样的，建议从网关层面，建立一个“可信cookie”白名单，自动过滤请求中的“非法cookie”字段。前端防篡改小程序前端更多是防“误改”————即在操作Cookie过程中，发生了意料之外的修改。通常发生在JS“引用拷贝”特性上，比如前面提到的内存维护一个 _Cookies ，如果有一个API getAllCookies() 直接将这份内存版cookies暴露出去，对象引用容易被连带修改。所以cookie基础库需要控制暴露API的能力范围，并对取值进行“深拷贝”。SessionSession机制将用户状态放在了服务端维护，具备更好的安全性，而且目前各种后端对于session的存储和同步都有很成熟的技术方案，有条件的业务应以Session为主做会话保持。指纹上报用户访问时生成设备指纹并上报（通常是登录/结算等环节），业务后台配合风控系统，遇到异常请求时下发验证环节。八、完整小程序实现Demo代码片段： developers.weixin.qq.com/s/x4sFASmh7…九、小结本文先解析了浏览器的 Cookie机制 运作原理，然后使用「数据缓存」和「网络」能力，以 公共基础库 的形式，在小程序中实现了一套 Cookie方案。希望对大家有所帮助。"}
{"title": "迷你PS小程序-集成的开放式画报、油墨电子签名、图片拖拽可单独食用 ... ", "author": null, "pub_time": null, "content": "米娜桑，哦哈哟~个人制作，该文章主要讲解最近基于 uni-app 框架编写的集图文拖拽等多方位编辑、油墨电子签名、开放式海报于一体的小程序的制作思路和实现代码。目录1、完整源码链接2、实现思路3、核心代码3-1、图文多方位编辑3-2、油墨电子签名3-3、开放式海报3-4、小结4.效果展示和体验1、完整源码链接：完整代码：https://github.com/TensionMax/mini-ps其中演示的文字编辑、图片编辑、油墨电子签名、开放式海报可单独食用，含文档说明。2、实现思路该工具主要由五个不同组件模块：文字编辑、图片编辑，油墨电子签名、控制、开放式海报1、文字编辑模块设置好的文字参数对象插入到文字队列中。2、图片编辑模块设置好的图片参数对象插入到图片队列中。3、油墨电子签名模块完成绘制后转为利用 canvasToTempFilePath 转成临时图片，获取参数后插入图片队列中，也可以直接导出。4、利用控制模块调整/文字队列和图片队列的参数。5、开放式海报模块，利用控制台的参数将PS画板上的效果绘制到canvas上来实现的效果，接着再利用 canvasToTempFilePath 转成图片导出。3、核心代码3-1、文字/图片编辑模块文字/图片编辑模块主要是实现移动/缩放功能，其他附带的属于甜品，由于两个模块功能类似，该篇仅讲解图片编辑模块。HTML<img\r\n style=\"position: absolute\"\r\n :style=\"{\r\n     left: item.x+'px', \r\n     top: item.y+'px',\r\n     width: item.w+'px',\r\n     height: item.h+'px',\r\n     }\"\r\n  @touchstart='touchStart($event,item,index)' \r\n  @longpress='longPress($event,item,index)'\r\n  @touchmove.stop='touchMove($event,item,index)' \r\n  @touchcancel=\"touchEnd($event,item,index)\" \r\n  @touchend='touchEnd($event,item,index)'\r\n  v-for=\"(item,index) of imagelist\"\r\n  :key=\"index\" \r\n  :src=\"item.src\"\r\n  />在 imageList 的数组标签中，每个绑定的事件中用 $event 来调用事件本身的参数，其中 $event 的 touches 或 changedTouches 包含我们需要的位置参数，示例如下：touches:[{\r\n        clientX: 14 //与显示区域(不含顶部栏)左上角的水平距离\r\n        clientY: 16 //与显示区域(不含顶部栏)左上角的垂直距离\r\n        pageX: 14 //与整个页面(不含顶部栏)左上角的水平距离\r\n        pageY: 16 //与整个页面(不含顶部栏)左上角的垂直距离\r\n        },\r\n        {\r\n        clientX: 14\r\n        clientY: 16\r\n        pageX: 14\r\n        pageY: 16\r\n        }]touches 长度为2代表双指触碰，通过判定双指触摸点的变化方向可实现双指缩放效果。因为每个标签都设置为 style=\"position: absolute\" 所以只需要根据位置参数来更新 x、y、w、h 即可题外话-性能问题一次移动多次操作DOM影响性能—— 虚拟DOM了解一下为何不用事件委派—— 不必要，Vue已经帮我们做了优化，在非常影响性能时再考虑图片编辑Demo3-2、油墨电子签名板由于 touchmove 事件在小程序真机的触发频率和精确度很迷，不太好根据速度来判定绘制的线宽，我只好用其他方式去实现，虽然效果不完美。其实现思路是通过多次的循环绘制以达到油墨效果，每次循环绘制的长度和宽度都不相同。HTML<canvas \r\ncanvas-id=\"canvas\" \r\n@touchstart.stop=\"touchStart\" \r\n@touchmove.stop=\"touchMove\"\r\n@touchend.stop=\"touchEnd\"\r\n>\r\n</canvas>JAVASCRIPTexport default {\r\ndata() {\r\n    return {\r\n        lineWidth0: 5, //初始线宽 建议1~5\r\n        ctx: null,\r\n        x0: 0, //初始横坐标或上一段touchmove事件中触摸点的横坐标\r\n        y0: 0, //初始纵坐标或上一段touchmove事件中触摸点的纵坐标\r\n        t0: 0, //初始时间或上一段touchmove事件发生时间\r\n        v0: 0, //初始速率或touchmove事件间发生速率\r\n        lineWidth: 0, //动态线宽\r\n        keenness: 5, //油墨程度 建议0~5\r\n        k: 0.3, //油墨因子，即每次绘制线条时线宽的变化程度\r\n    }\r\n},\r\nonReady() {\r\n    this.ctx = uni.createCanvasContext('canvas', this);\r\n    this.ctx.setLineCap('round')\r\n},\r\nmethods: {\r\n    //设置初始值\r\n    touchStart(e) {\r\n        this.lineWidth = this.lineWidth0\r\n        this.t0 = new Date().getTime()\r\n        this.v0 = 0\r\n        this.x0 = e.touches[0].clientX\r\n        this.y0 = e.touches[0].clientY\r\n    },\r\n\r\n    touchMove(e) {\r\n        let dx = e.touches[0].clientX - this.x0,\r\n            dy = e.touches[0].clientY - this.y0,\r\n            ds = Math.pow(dx * dx + dy * dy, 0.5),\r\n            dt = (new Date().getTime()) - this.t0,\r\n            v1 = ds / dt; //同 this.v0 初始速率或touchmove事件间发生速率\r\n        if (this.keenness === 0) { //油墨为0时\r\n            this.ctx.moveTo(this.x0, this.y0)\r\n            this.ctx.lineTo(this.x0 + dx, this.y0 + dy)\r\n            this.ctx.setLineWidth(this.lineWidth)\r\n            this.ctx.stroke()\r\n            this.ctx.draw(true)\r\n        } else {\r\n            //由于touchMove的触发频率问题，这里采用for循环绘制，原理如图所示\r\n            //这里的k因为\r\n            let a = this.keenness\r\n            if (this.keenness > 5) {\r\n                a = 5\r\n            }\r\n            for (let i = 0; i < a; i++) {\r\n                this.ctx.moveTo(this.x0 + dx * i / a, this.y0 + dy * i / a)\r\n                this.ctx.lineTo(this.x0 + dx * (i + 1) / a, this.y0 + dy * (i + 1) / a)\r\n                //此时touchmove事件间发生与上一个事件的发生的速率比较\r\n                if (v1 < this.v0) {\r\n                    this.lineWidth -= this.k\r\n                    if (this.lineWidth < this.lineWidth * 0.25) this.lineWidth = this.lineWidth * 0.25\r\n                } else {\r\n                    this.lineWidth += this.k\r\n                    if (this.lineWidth > this.lineWidth * 1.5) this.lineWidth = this.lineWidth * 1.5\r\n                }\r\n                this.ctx.setLineWidth(this.lineWidth)\r\n                this.ctx.stroke()\r\n                this.ctx.draw(true)\r\n            }\r\n        }\r\n        this.x0 = e.touches[0].clientX\r\n        this.y0 = e.touches[0].clientY\r\n        this.t0 = new Date().getTime()\r\n        this.v0 = v1\r\n    },\r\n    touchEnd(e) {\r\n        this.x0 = 0\r\n        this.y0 = 0\r\n        this.t0 = 0\r\n        this.v0 = 0\r\n    }\r\n}\r\n}使用的大部分是canvas的基础api，注意绘制单位都为px。油墨电子签名Demo3-3、开放式海报模块如果说微信小程序是银色金滩，那么截至2020年1月6日或者未来，小程序的canvas就是金滩上充斥着未知数个的玻璃块的那一片 ——鲁迅说起小程序canvas，那bug不是一般的多，部分不常见bug我会在代码注释里说明。HTML<canvas canvas-id=\"generate\" :style=\"{ width: canvasW + 'rpx', height: canvasH + 'rpx'}\"></canvas>相关介绍spread 语法async 函数如果图片是网络路径，记得获取临时路径。//别忘了在函数前加 async\r\nlet src = 'https://s2.ax1x.com/2020/01/05/lrCDx0.jpg'\r\nsrc = (await uni.getImageInfo({src}))[1].path;JAVASCRIPT输出字段部分//为方便设置，以下除角度外，单位均以rpx为主\r\ndata() {\r\n    return {\r\n        canvasW:720,\r\n        canvasH:1000,\r\n        img:[{\r\n            src: 'https://s2.ax1x.com/2020/01/05/lrCDx0.jpg',\r\n            x: 0,\r\n            y: 0,\r\n            w: 100,\r\n            h: 100,\r\n            r: 50,//圆角度\r\n            degrees: 30,//旋转度\r\n            mirror: true//是否镜像\r\n            }],\r\n        text:[{\r\n                content: 'TensionMax',\r\n                x: 50,\r\n                y: 50,\r\n                w: 100,\r\n                lineHeight: 35,//行间距\r\n                color: '#000000',\r\n                size: 28,\r\n                weight: 'normal',//字体粗细\r\n                lineThrough: true,//是否贯穿\r\n            }],\r\n        ctx: null,\r\n        k: null //单位转换因子\r\n    };\r\n}JAVASCRIPTrpx 或 upx与 px 的单位统一转换方法px2rpx() {\r\n    //当转换的参数只有一个时直接返回数值如\r\n    //当不为一个时返回数组，然后用spread语法将其展开为几个参数\r\n    //Math.floor()是为了防止在安卓机上造成的数据紊乱，开发者工具无此bug\r\n    if (arguments.length === 1) return Math.floor(arguments[0] / this.k)\r\n    let params = []\r\n    for (let i of arguments) {\r\n        params.push(Math.floor(i / this.k))\r\n    }\r\n    return params\r\n},\r\nrpx2px() {\r\n    if (arguments.length === 1) return Math.floor(arguments[0] * this.k)\r\n    let params = []\r\n    for (let i of arguments) {\r\n        params.push(Math.floor(i * this.k))\r\n    }\r\n    return params\r\n},JAVASCRIPT绘制图片的函数async drawImg() {\r\nthis.ctx.setFillStyle('#FFFFFF')\r\nthis.ctx.fillRect(0, 0, ...this.rpx2px(this.canvasW, this.canvasH)) //绘制背景\r\nfor (let i of this.img) { //for循环绘制图片\r\n    i.src = (await uni.getImageInfo({src: i.src}))[1].path;//获取图片临时路径\r\n    this.ctx.save() //保存当前绘制内容\r\n    if (i.mirror) { //如果设置镜像\r\n        //因为canvas的translate属性是基于原点（初始原点为右上角）变化\r\n        //所以需要先将原点移动至图片中心，变化后再还原\r\n        //旋转变化同理\r\n        this.ctx.translate(...this.rpx2px(i.x + i.w / 2, i.y + i.h / 2))\r\n        this.ctx.scale(-1, 1)\r\n        this.ctx.translate(...this.rpx2px(-i.x - i.w / 2, -i.y - i.h / 2))\r\n    }\r\n    if (i.degrees) { //如果设置旋转\r\n        this.ctx.translate(...this.rpx2px(i.x + i.w / 2, i.y + i.h / 2))\r\n        this.ctx.rotate(i.degrees * Math.PI / 180)\r\n        this.ctx.translate(...this.rpx2px(-i.x - i.w / 2, -i.y - i.h / 2))\r\n    }\r\n    this.radiusRect(...this.rpx2px(i.x, i.y, i.w, i.h, i.r)) //圆角或矩形路径绘制\r\n    this.ctx.clip() //裁剪\r\n    this.ctx.drawImage(i.src, ...this.rpx2px(i.x, i.y, i.w, i.h))\r\n    this.ctx.restore() //恢复非裁剪区域\r\n}\r\nthis.ctx.draw(true) \r\n}\r\n\r\nradiusRect(x, y, w, h, r) {\r\n    if (r > w / 2 || r > h / 2) {\r\n        r = Math.min(w, h) / 2\r\n    }\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(x, y); // 将操作点移至左上角\r\n    this.ctx.arcTo(x + w, y, x + w, y + r, r); // 画右上角的弧\r\n    this.ctx.lineTo(x + w, y) //可省略，但由于安卓真机的小程序bug，留之，下同。\r\n    this.ctx.arcTo(x + w, y + h, x + w - r, y + h, r); // 画右下角的弧\r\n    this.ctx.lineTo(x + w, y + h) //可省略\r\n    this.ctx.arcTo(x, y + h, x, y + h - r, r); // 画左下角的弧\r\n    this.ctx.lineTo(x, y + h) //可省略\r\n    this.ctx.arcTo(x, y, x + r, y, r); // 画左上角的弧\r\n    this.ctx.lineTo(x, y) //可省略\r\n},绘制自定义文字文字绘制稍微麻烦些，主要是canvas不会自动帮我们换行排版，网上类似的实现方法太多，该篇就不讲，直接放在Demo里面。开放式海报Demo3-4、小结既然我们知道了这几个组件自定义调整参数的方式，那么最后只需要一个父组件作为控制台来调整他们的参数即可，可以通过 props 、 sync 修饰符 等来实现父子通信，当然如果想做更复杂的可以考虑用 Vuex 传参。接下来就可以根据这思路来实现繁琐的业务逻辑了。4、效果展示效果图如下，如果由什么疑问欢迎到下方评论区讨论。"}
{"title": "小程序、H5登录授权、分享、支付流程 ", "author": null, "pub_time": null, "content": "前言对于前端来说，微信的 支付 、 分享 、 登录 是一定要掌握的，今天这篇文章，主要对这三方面的流程进行详细的介绍。主要内容如下：域名相关知识介绍该网站不安全，请不要输入密码\r\n微信小程序授权登录流程op=>operation: openid判断是否登录授权\r\nop2=>operation: 根据wx.login获取code\r\nop3=>operation: 调用服务端根据code换取openid\r\nop4=>operation: 通过用户授权，获取信息，存到数据库\r\nop->op2->op3->op4\r\n复制代码如果你从来没有阅读过小程序登录授权的文档，建议你看一下下面的地址：服务端官方文档 客户端文档nodejs + 小程序实现授权登录前端部分根据本地是否有userId判断是否登录，如果没有登录，则获取用户的openidonLoad() {\r\n   if(!this.data.userId) {\r\n       this.getSession()\r\n   }\r\n},\r\n getSession() {\r\n   wx.login({\r\n     success: (res) => {\r\n       if (res.code) {\r\n         app.get(Api.getSession, {\r\n           code: res.code\r\n         }).then(res => {\r\n           store.setItem('openid', res.openid)\r\n         })\r\n       }\r\n     }\r\n   })\r\n }复制代码点击授权按钮，发起登录请求。getUserInfo(e) {\r\n    let userInfo = e.detail.userInfo;\r\n    userInfo.openid = store.getItem('openid')\r\n    app.get(Api.login, {\r\n        userInfo\r\n    }).then(res => {\r\n        store.setItem('userId', res.data.userId)\r\n        this.setData({\r\n            userId: res.userId\r\n        })\r\n    })\r\n}复制代码服务端部分在 config 里面，定义公用的 appid 和 appsecretmodule.exports = {\r\n    wx: {\r\n        appId: 'wx0ef10432747d8f57',\r\n        appsecret: 'cc47a6127687e999a1dffa756ff83c0e'\r\n    },\r\n    mp: {\r\n        appId: 'wx0691f1dcf6e5e231',\r\n        appSecret: 'c7ed875e338120f15f49476a6596eb4f'\r\n    }\r\n}复制代码然后通过调用小程序 官方文档 的接口，获取到 appid 传给客户端let express = require('express');\r\nlet router = express.Router();\r\nlet request = require('request');\r\nlet config = require('./config');\r\nlet uril = require('./../../util/index')\r\nconfig = Object.assign({}, config.mp);\r\n\r\nrouter.get('/getSession', (req, res) => {\r\n    let code = req.query.code\r\n    if (!code) {\r\n        res.json(uril.handleFail('code不能为空', 10001))\r\n    }\r\n    let sessionUrl = `https://api.weixin.qq.com/sns/jscode2session?appid=${config.appId}&secret=${config.appSecret}&js_code=${code}&grant_type=authorization_code`;\r\n    request(sessionUrl, (err, response, body) => {\r\n        let result = util.handleResponse(err, response, body)\r\n        res.json(result)\r\n    })\r\n})复制代码登录接口 的编写// 小程序授权登录\r\nrouter.get('/login',async function(req,res){\r\n  let userInfo = JSON.parse(req.query.userInfo);\r\n  if (!userInfo){\r\n    // 如果接口没有信息，则返回错误信息\r\n    res.json(util.handleFail('用户信息不能为空',10002))\r\n  }else{\r\n    // 查询当前用户是否已经注册\r\n    let userRes = await dao.query({ openid: userInfo.openid},'users_mp');\r\n    if (userRes.code == 0){\r\n      // 如果已经注册，直接把查出来的信息返回给客户端\r\n      if (userRes.data.length >0){\r\n        res.json(util.handleSuc({\r\n          userId: userRes.data[0]._id\r\n        }))\r\n      }else{\r\n        // 如果这个用户之前没有注册，则在数据库插入用户信息\r\n        let insertData = await dao.insert(userInfo,'users_mp');\r\n        if (insertData.code == 0){\r\n          let result = await dao.query({ openid: userInfo.openid }, 'users_mp');\r\n          res.json(util.handleSuc({\r\n            userId: result.data[0]._id\r\n          }))\r\n        }else{\r\n          res.json(insertData);\r\n        }\r\n      }\r\n    }else{\r\n      res.json(userRes);\r\n    }\r\n  }\r\n})复制代码上述代码的 handleFail 和 handleResponse 是封装的对数据的统一处理，如果有兴趣，参见 github 地址。这里不展示代码。需要注意的是，这种实现方式，获取 openid 的行为放在后端实现了。如果放在前端实现也可以，但是会相对比较麻烦一点。此时，suerId就已经在数据库存储，并且在本地保存了，下次登录的时候，如果有userId存在就不需要再次登录了。H5的登录授权和分享流程H5的登录授权略有不同。如果用户登录授权页面，发现该用户没有登录授权，则需要跳转到授权页面。 官方文档 给出的流程如下：1 第一步：用户同意授权，获取code2 第二步：通过code换取网页授权access_token3 第三步：刷新access_token（如果需要）4 第四步：拉取用户信息(需scope为 snsapi_userinfo)5 附：检验授权凭证（access_token）是否有效在项目中代码如下：(这里代码没有实现刷新access_token和拉取用户信息)页面加载的时候，判断是否已经授权。mounted(){\r\n   this.checkUserAuth();\r\n },\r\nmethods:{\r\n// 检查用户是否授权过\r\ncheckUserAuth(){\r\n  let openId = this.$cookie.get('openId');\r\n  if(!openId){\r\n    // 如果没有登录授权，则跳转到微信提供的跳转页面。\r\n    window.location.href = API.wechatRedirect;\r\n  }else{\r\n  // 如果用户已经授权，则调用获取微信配置信息接口\r\n    this.getWechatConfig();\r\n  }\r\n},复制代码API.wechatRedirect:wechatRedirect:'/api/wechat/redirect?url=http%3A%2F%2Fm.51purse.com%2F%23%2Findex&scope=snsapi_userinfo',复制代码「注意」url地址需要 encodeURIComponent 编码才可以。m.51purse.com 需要与你在微信公众号后台配置的 授权域名 一致！nodejs 对登录授权回调接口的实现主要是拿到客户端的请求参数，请求微信提供的 接口// 用户授权重定向\r\nrouter.get('/redirect',function (req,res) {\r\n  let redirectUrl = req.query.url, scope = req.query.scope, callback = 'http://m.51purse.com/api/wechat/getOpenId';\r\n  cache.put('redirectUrl', redirectUrl);\r\n  // 获取到客户端带过来的数据，请求微信接口\r\n  let authorizeUrl = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=${config.appId}&redirect_uri=${callback}&response_type=code&scope=${scope}&state=STATE#wechat_redirect`;\r\n  res.redirect(authorizeUrl);\r\n})\r\n复制代码当用户点击 确认授权 之后，会执行跳转 callbacl：http://m.51purse.com/api/wechat/getOpenId 。而这个接口也是node端实现的，具体内容如下：// 用code换取access_token的方法\r\nexports.getAccessToken = function(code){\r\n  let token_url = `https://api.weixin.qq.com/sns/oauth2/access_token?appid=${config.appId}&secret=${config.appSecret}&code=${code}&grant_type=authorization_code`;\r\n  return new Promise((resolve, reject) => {\r\n    request.get(token_url, function (err, response, body) {\r\n      let result = util.handleResponse(err, response, body);\r\n      resolve(result);\r\n    })\r\n  });\r\n}\r\n\r\n\r\n// 根据code获取用户的OpenId\r\nrouter.get('/getOpenId',async function(req,res){\r\n  let code = req.query.code;\r\n  console.log(\"code:\"+code);\r\n  if(!code){\r\n    res.json(util.handleFail('当前未获取到授权code码'));\r\n  }else{\r\n    // 用code换取access_token\r\n    let result = await common.getAccessToken(code);\r\n    if(result.code == 0){\r\n      // 换取access_token成功\r\n      let data = result.data;\r\n      let expire_time = 1000 * 60 * 60 * 2;\r\n      // 往客户端写入cookie：openId\r\n      res.cookie('openId', data.openid, { maxAge: expire_time });\r\n      let openId = data.openid;\r\n      let userRes = await dao.query({ 'openid': openId },'users');\r\n      if (userRes.code == 0){\r\n        if (userRes.data.length>0){\r\n          // 从数据库查找到用户信息后，回调到客户端的页面\r\n          let redirectUrl = cache.get('redirectUrl');\r\n          res.redirect(redirectUrl);\r\n        }else{\r\n          let userData = await common.getUserInfo(data.access_token, openId);\r\n          let insertData = await dao.insert(userData.data,'users');\r\n          if (insertData.code == 0){\r\n            // 从数据库查找到用户信息后，回调到客户端的页面\r\n            let redirectUrl = cache.get('redirectUrl');\r\n            res.redirect(redirectUrl);\r\n          }else{\r\n            // 返回错误信息\r\n            res.json(insertData);\r\n          }\r\n        }\r\n      }else{\r\n        // 返回错误信息\r\n        res.json(userRes);\r\n      }\r\n    }else{\r\n      // 返回错误信息\r\n      res.json(result);\r\n    }\r\n  }\r\n})\r\n复制代码「注意」：上面的代码为了简单，删除了一些不必要的代码，如有兴趣，访问gitHub。H5分享流程同样，如果你没有阅读过微信H5开发的 官方文档 ,建议你先阅读。关于分享，你应该阅读以下内容：当再次回调到页面的时候，从cookie已经拿到openId了。客户端会继续执行下面的代码。获取到服务端返回的配置信息，从而初始化分享的功能。在这之前，你需要 npm install wx-jssdk// 这个信息统一定义在api.js中，这里为了方便，放在前面，便于查看。\r\nAPI.wechatConfig: /api/wechat/jssdk\r\n\r\n\r\n// 获取微信配置信息\r\ngetWechatConfig(){\r\n  this.$http.get(API.wechatConfig+'?url='+location.href.split('#')[0]).then(function(response){\r\n    let res = response.data;\r\n    if(res.code == 0){\r\n      let data = res.data;\r\n      wx.config({\r\n        debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\r\n        appId: data.appId, // 必填，公众号的唯一标识\r\n        timestamp: data.timestamp, // 必填，生成签名的时间戳\r\n        nonceStr: data.nonceStr, // 必填，生成签名的随机串\r\n        signature: data.signature,// 必填，签名\r\n        jsApiList: data.jsApiList // 必填，需要使用的JS接口列表\r\n      })\r\n      wx.ready(()=>{\r\n        util.initShareInfo(wx);\r\n      })\r\n    }\r\n  })\r\n}复制代码util/index.js 里面对分享的功能进行了封装。export default {\r\n  //获取浏览器地址栏参数值\r\n  getUrlParam(name){\r\n    let reg = new RegExp('(^|&)'+name+'=([^&]*)');\r\n    let r = window.location.search.substr(1).match(reg);\r\n    if(r!=null)return decodeURIComponent(r[2]);\r\n  },\r\n  initShareInfo(wx){\r\n    let shareInfo = {\r\n      title: 'xxxx', // 分享标题\r\n      desc: 'xxxx', // 分享描述\r\n      link: 'http://m.51purse.com/#/index', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致\r\n      imgUrl: '', // 分享图标\r\n    }\r\n    wx.onMenuShareAppMessage(shareInfo);\r\n    wx.onMenuShareTimeline(shareInfo);\r\n    wx.onMenuShareQQ(shareInfo);\r\n    wx.onMenuShareQZone(shareInfo);\r\n    // 下面两种方法为新的方法,上面的方法将会被淘汰。\r\n    wx.updateAppMessageShareData(shareInfo);\r\n    wx.updateTimelineShareData(shareInfo);\r\n  }\r\n}\r\n复制代码nodejs端对 /wechat/jssdk 接口的实现如下：// common.getToken()方法 获取基础接口的Token\r\n\r\nexports.getToken = function(){\r\n  let token = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${config.appId}&secret=${config.appSecret}`;\r\n  return new Promise((resolve, reject)=>{\r\n    request.get(token, function (err, response, body) {\r\n      let result = util.handleResponse(err, response, body);\r\n      resolve(result);\r\n    })\r\n  })\r\n}\r\n----\r\n\r\nrouter.get('/jssdk',async function(req,res){\r\n  let url = req.query.url;\r\n  let result = await common.getToken();\r\n  if (result.code == 0){\r\n    let token = result.data.access_token;\r\n    let params = {\r\n      // 生成随机字符串\r\n      noncestr:util.createNonceStr(),\r\n      // 生成时间戳\r\n      timestamp:util.createTimeStamp(),\r\n      url\r\n    }\r\n      let str = util.raw(params);\r\n      console.log('str:::' + JSON.stringify(params))\r\n      let sign = createHash('sha1').update(str).digest('hex');\r\n      res.json(util.handleSuc({\r\n        appId: config.appId, // 必填，公众号的唯一标识\r\n        timestamp: params.timestamp, // 必填，生成签名的时间戳\r\n        nonceStr: params.noncestr, // 必填，生成签名的随机串\r\n        signature: sign,// 必填，签名\r\n        jsApiList: [\r\n          'updateAppMessageShareData',\r\n          'updateTimelineShareData',\r\n          'onMenuShareTimeline',\r\n          'onMenuShareAppMessage',\r\n          'onMenuShareQQ',\r\n          'onMenuShareQZone',\r\n          'chooseWXPay'\r\n        ] // 必填，需要使用的JS接口列表\r\n      }))\r\n    }\r\n  }else{\r\n    res.json(result);\r\n  }\r\n})复制代码以上代码主要获得基础的 token ,然后用基础 token 结合签名、时间戳、随机数等相关的参数，返回给客户端相应的参数。需要注意的是， 基础token 和 accessToken 的区别。建议 参考文章 。到此，微信H5接入jssdk实现分享就已经完成了。小程序支付小程序支付前端流程获取openId调起数字签名后端支付流程拼接常规参数生成签名拼接xml数据调用下单接口获取预支付Id：prepay_id生成支付sdk定义回调接口，接受微信支付消息支付的主要逻辑在服务端下面把服务端的流程通过代码的方式表述出来。首先在util中封装了一些支付需要的公共方法/**\r\n * 公共函数定义\r\n */\r\nlet createHash = require('create-hash');\r\nmodule.exports = {\r\n  // 生成随机数\r\n  createNonceStr(){\r\n    return Math.random().toString(36).substr(2,15);\r\n  },\r\n  // 生成时间戳\r\n  createTimeStamp(){\r\n    return parseInt(new Date().getTime() / 1000) + ''\r\n  },\r\n  // 生成签名\r\n  getSign(params, key){\r\n    let string = this.raw(params) + '&key=' + key;\r\n    let sign = createHash('md5').update(string).digest('hex');\r\n    return sign.toUpperCase();\r\n  },\r\n  // 生成系统的交易订单号\r\n  getTradeId(type='wx'){\r\n    let date = new Date().getTime().toString();\r\n    let text = '';\r\n    let possible = '0123456789';\r\n    for(let i=0;i<5;i++){\r\n      text += possible.charAt(Math.floor(Math.random() * possible.length))\r\n    }\r\n    return (type == 'wx'?'ImoocWxJuZi':'ImoocMpJuZi') + date + text;\r\n  },\r\n  // Object 转换成json并排序\r\n  raw(args){\r\n    let keys = Object.keys(args).sort();\r\n    let obj = {};\r\n    keys.forEach((key)=>{\r\n      obj[key] = args[key];\r\n    })\r\n    // {a:1,b:2} =>  &a=1&b=2\r\n    // 将对象转换为&分割的参数\r\n    let val = '';\r\n    for(let k in obj){\r\n      val += '&' + k + '=' +obj[k];\r\n    }\r\n    return val.substr(1);\r\n  }\r\n}复制代码下面是对支付的方法的封装，其中调用了util中的函数。客户端调用的就是下面的 order 方法。/**\r\n * 微信小程序、H5通用支付封装\r\n */\r\nlet config = require('./../pay/config')\r\nlet request = require('request')\r\nlet util = require('../../util/util')\r\nlet createHash = require('create-hash')\r\nlet xml = require('xml2js')\r\nconfig = config.mch;\r\nmodule.exports = {  \r\n  order: function (appid,attach, body, openid, total_fee, notify_url, ip){\r\n    return new Promise((resolve,reject)=>{\r\n      let nonce_str = util.createNonceStr();\r\n      let out_trade_no = util.getTradeId('mp');\r\n      // 支付前需要先获取支付签名\r\n      let sign = this.getPrePaySign(appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no);\r\n      // 通过参数和签名组装xml数据，用以调用统一下单接口\r\n      let sendData = this.wxSendData(appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no, sign);\r\n      let self = this;\r\n      let url = 'https://api.mch.weixin.qq.com/pay/unifiedorder';\r\n      request({\r\n        url,\r\n        method: 'POST',\r\n        body: sendData\r\n      }, function (err, response, body) {\r\n        if (!err && response.statusCode == 200) {\r\n          xml.parseString(body.toString('utf-8'),(error,res)=>{\r\n            if(!error){\r\n              let data = res.xml;\r\n              console.log('data:' + JSON.stringify(data));\r\n              if (data.return_code[0] == 'SUCCESS' && data.result_code[0] == 'SUCCESS'){\r\n                // 获取预支付的ID\r\n                let prepay_id = data.prepay_id || [];\r\n                let payResult = self.getPayParams(appid, prepay_id[0]);\r\n                resolve(payResult);\r\n              }\r\n            }\r\n          })\r\n        } else {\r\n          resolve(util.handleFail(err));\r\n        }\r\n      })\r\n    })\r\n  },\r\n  // 生成预支付的签名\r\n  getPrePaySign: function (appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no) {\r\n    let params = {\r\n      appid,\r\n      attach,\r\n      body,\r\n      mch_id: config.mch_id,\r\n      nonce_str,\r\n      notify_url,\r\n      openid,\r\n      out_trade_no,\r\n      spbill_create_ip: ip,\r\n      total_fee,\r\n      trade_type: 'JSAPI'\r\n    }\r\n    let string = util.raw(params) + '&key=' + config.key;\r\n    let sign = createHash('md5').update(string).digest('hex');\r\n    return sign.toUpperCase();\r\n  },\r\n  // 签名成功后 ，根据参数拼接组装XML格式的数据，调用下单接口\r\n  wxSendData: function (appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no,sign) {\r\n    let data = '<xml>' + \r\n      '<appid><![CDATA[' + appid + ']]></appid>' + \r\n      '<attach><![CDATA[' + attach + ']]></attach>' + \r\n      '<body><![CDATA[' + body + ']]></body>' + \r\n      '<mch_id><![CDATA[' + config.mch_id + ']]></mch_id>' + \r\n      '<nonce_str><![CDATA[' + nonce_str + ']]></nonce_str>' + \r\n      '<notify_url><![CDATA[' + notify_url + ']]></notify_url>' + \r\n      '<openid><![CDATA[' + openid + ']]></openid>' + \r\n      '<out_trade_no><![CDATA[' + out_trade_no + ']]></out_trade_no>' + \r\n      '<spbill_create_ip><![CDATA[' + ip + ']]></spbill_create_ip>' + \r\n      '<total_fee><![CDATA[' + total_fee + ']]></total_fee>' + \r\n      '<trade_type><![CDATA[JSAPI]]></trade_type>' + \r\n      '<sign><![CDATA['+sign+']]></sign>' + \r\n    '</xml>'\r\n    return data;\r\n  },\r\n  getPayParams:function(appId,prepay_id){\r\n    let params = {\r\n      appId,\r\n      timeStamp:util.createTimeStamp(),\r\n      nonceStr:util.createNonceStr(),\r\n      package: 'prepay_id=' + prepay_id,\r\n      signType:'MD5'\r\n    }\r\n    let paySign = util.getSign(params,config.key);\r\n    params.paySign = paySign;\r\n    return params;\r\n  }\r\n}复制代码最后定义 /pay/payWallet 的支付接口，里面调用公用的order方法。// 小程序支付\r\nrouter.get('/pay/payWallet',function(req,res){\r\n  let openId = req.query.openId;//用户的openid\r\n  let appId = config.appId;//应用的ID\r\n  let attach = \"小程序支付课程体验\";//附加数据\r\n  let body = \"欢迎学习慕课首门支付专项课程\";//支付主体内容\r\n  let total_fee = req.query.money;//支付总金额\r\n  let notify_url = \"http://localhost:3000/api/mp/pay/callback\"\r\n  let ip = \"123.57.2.144\";\r\n  wxpay.order(appId,attach,body,openId,total_fee,notify_url,ip).then((result)=>{\r\n    res.json(util.handleSuc(result));\r\n  }).catch((result)=>{\r\n    res.json(util.handleFail(result.toString()))\r\n  });\r\n})复制代码这里的流程请参见 官方描述 。官方描述的非常清楚，这儿就不描述更多了，其实主要就是拼接一些参数，获取 签名 。然后根据签名加上其他需要的 参数 (参见上述代码)再凭借xml的数据。然后再调用统一下单接口 https://api.mch.weixin.qq.com/pay/unifiedorder 。生成 prepay_id之后，生成小程序端需要的一些参数，然后把这些参数返回个小程序客户端，供小程序的客户端调用微信小程序的支付功能。小程序前端支付非常简单，只是简单的调用服务端提供的 payWallet 接口，传入 openId 和 money 即可。然后获取到相应的参数，调用微信提供的 requestPayment 拉起支付即可。主要代码逻辑如下：pay() {\r\n    app.get(Api.payWallet,{\r\n      openId: Store.getItem('openId'),\r\n      money: this.data.index\r\n    }).then((res) => {\r\n      // 支付\r\n      wx.requestPayment({\r\n        timeStamp: res.timeStamp,\r\n        nonceStr: res.nonceStr,\r\n        package: res.package,\r\n        signType: res.signType,\r\n        paySign: res.paySign,\r\n        success: function (errmsg) {\r\n          if (errmsg == 'requestPayment:ok') {\r\n            wx.showToast({\r\n              title: '支付成功',\r\n              icon: 'success'\r\n            });\r\n          }\r\n        },\r\n        fail: function (res) {\r\n          if (res.errMsg == 'requestPayment:fail cancel') {\r\n            wx.showToast({\r\n              title: '支付取消',\r\n              icon: 'none'\r\n            });\r\n          } else {\r\n            wx.showToast({\r\n              title: res.errmsg,\r\n              icon: 'none'\r\n            });\r\n          }\r\n        }\r\n      })\r\n    });\r\n  }\r\n复制代码到这里，小程序端的支付功能就已经实现了。"}
{"title": "红包小程序小结 ", "author": null, "pub_time": null, "content": "最近做了一个红包兑换小程序，遇到了一些问题这里做一下总结。1、需求：回流用户在游戏客户端获取到口令，然后在小程序这边输入口令兑换红包，成功之后钱会发到用户微信账户里。2、流程：若未授权，显示授权按钮。点击授权登录，授权成功后获取到私密字段iv和encryptedData，调取登陆接口，错误则提示相关信息，正确则跳转校验姓名和身份证的页面，校验通过就调取提现接口，成功则提示提现成功，同时显示生成分享图按钮。分享图由用户昵称，头像，二维码，提现金额等等组成。3、框架：uniapp分享图的问题1、 measureText 获取宽度的时候，传入的参数如果是数字，则会返回0。let money = 10;  //这里需要把数字转成字符串\r\nctx.measureText(money).width;\r\n2、绘制图片的时候不要忘了先使用 getImageInfo 转成临时地址，再 drawImage ，如果不经过这步，虽然开发者工具上看到是正常的，但是真机是显示不了。3、需要绘制微信头像的时候，要在后台配置downloadFile合法域名 https://wx.qlogo.cn 4、最初背景图大概170KB，尺寸750*1334，最终绘制出来的分享图太大了。解决方法：把背景图片尽量再压缩，最终是60多KB。调 canvasToTempFilePath 的时候，设置 fileType 为jpg，quality范围是(0,1]，取个合适的值。 5、小程序里面的保存图片并不是长按保存的，需要点击按钮授权。<button  open-type=\"getUserInfo\"  @getuserinfo=\"onGotUserInfo\"></button>、\r\n...\r\nonGotUserInfo(e){\r\n\tuni.saveImageToPhotosAlbum({\r\n\t\tfilePath: this.tempPath,\r\n\t\tsuccess(res) {\r\n\t\t\tuni.showToast({\r\n\t\t\t  title: '保存成功',\r\n\t\t\t  icon: 'success',\r\n\t\t\t  duration: 1500\r\n\t\t\t})\r\n\t\t},\r\n\t\tfail(err){\r\n\t\r\n\t\t}\r\n\t})\r\n}\r\n...\r\n如图：如果用户点击确定，就会正常保存图片到本地相册了。如果用户点击取消，不授权呢？那还能怎么样，点击再弹出原来的弹窗重新授权呗。很遗憾，这里并不能像授权登录弹窗一样点了取消之后，再次点击授权按钮还会唤起那个弹窗。解决方法：在 saveImageToPhotosAlbum 的fail回调函数里面操作，再次获取保存到相册权限。if (err.errMsg === \"saveImageToPhotosAlbum:fail:auth denied\" || err.errMsg === \"saveImageToPhotosAlbum:fail authorize no response\" || err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\r\n  uni.showModal({\r\n\ttitle: '提示',\r\n\tcontent: '需要您授权保存相册',\r\n\tshowCancel: false,\r\n\tsuccess:res=>{\r\n\t  uni.openSetting({\r\n\t\tsuccess(settingdata) {\r\n\t\t  if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n\t\t\tuni.showModal({\r\n\t\t\t  title: '提示',\r\n\t\t\t  content: '获取权限成功,再次点击保存图片按钮即可保存',\r\n\t\t\t  showCancel: false,\r\n\t\t\t})\r\n\t\t  } else {\r\n\t\t\tuni.showModal({\r\n\t\t\t  title: '提示',\r\n\t\t\t  content: '获取权限失败，将无法保存到相册哦~',\r\n\t\t\t  showCancel: false,\r\n\t\t\t})\r\n\t\t  }\r\n\t\t},\r\n\t\tfail(failData) {\r\n\t\t  console.log(\"failData\",failData)\r\n\t\t},\r\n\t\tcomplete(finishData) {\r\n\t\t  console.log(\"finishData\", finishData)\r\n\t\t}\r\n\t  })\r\n\t}\r\n  })\r\n}\r\n点击取消按钮之后，会跳转到这里。打开设置里的“保存到相册”的开关即可。原生微信小程序和uniapp框架的一些对比针对此次项目，这里挑两点来写。全局变量的管理1、原生微信小程序可以在app.js的globalData对象中对全局变量进行管理app.jsApp({\r\n    globalData: {\r\n        session:\"\"\r\n    }\r\n})\r\npages/index/index.js...\r\nconst app = getApp()//获取应用实例\r\napp.globalData.session = \"xxxx\" //设置\r\napp.globalData.session  //读取\r\n...\r\n2、uniapp用的是vue的那套，所以可以用vuex来管理状态import Vue from 'vue'\r\nimport Vuex from 'vuex'\r\nVue.use(Vuex);\r\nconst store = new Vuex.Store({\r\n\t state : {\r\n\t\tsession:\"\"\r\n\t },\r\n\t mutations : {\r\n\t\tgetSession(state, res){\r\n\t\t\tstate.session = res;\r\n\t\t},\r\n\t }\r\n});\r\nexport default store\r\n设置this.$store.commit('getSession',res.session) //接口返回res.session\r\n获取this.$store.state.session\r\n页面获取全局函数返回的值1、原生微信小程序，比如在app.js中获取用户信息保存在 globalData 中userInfo字段，然后页面在onload的时候获取全局的userInfo，你会发现有时候拿不到。由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回，所以需要加入 callback 以防止这种情况。app.jsApp({\r\n  onLaunch: function() {\r\n    this.init()\r\n  },\r\n  init: function() {\r\n    // 获取用户授权结果\r\n    wx.getSetting({\r\n      success: (res) => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          wx.getUserInfo({ // 获取用户信息\r\n            success: res => {\r\n              this.globalData.userInfo = res.userInfo;\r\n              if (this.userInfoReadyCallback) {\r\n                this.userInfoReadyCallback(res)\r\n              }\r\n            },\r\n            //拒绝授权\r\n            fail: res => {\r\n\r\n            }\r\n          })\r\n        } else {\r\n\r\n        }\r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    userInfo: \"\"\r\n  }\r\n})\r\npages/index/index.jsconst app = getApp()\r\nPage({\r\n  data: {\r\n\tuserInfo:\"\"\r\n  },\r\n  onLoad: function() {\r\n    if (app.globalData.userInfo) {\r\n      this.setData({\r\n        userInfo: app.globalData.userInfo,\r\n      })\r\n    } else{\r\n      app.userInfoReadyCallback = res => {\r\n        this.setData({\r\n          userInfo: res.userInfo,\r\n        })\r\n      }\r\n    } \r\n  },\r\n})\r\n2、uniapp是配合vuex和计算属性computed来处理的APP.vueexport default {\r\n\tonLaunch: function() {\r\n\t\tthis.getUserInfo();\r\n\t},\r\n\tmethods:{\r\n\t\tgetUserInfo() {\r\n\t\t\tuni.getSetting({\r\n\t\t\t  success: (res) => {\r\n\t\t\t\tif (res.authSetting['scope.userInfo']) {\r\n\t\t\t\t  uni.getUserInfo({ // 获取用户信息 \r\n\t\t\t\t\tsuccess: res => {\r\n\t\t\t\t\t\tthis.$store.commit('userInfo',{\r\n\t\t\t\t\t\t\tavatarUrl:res.userInfo.avatarUrl,\r\n\t\t\t\t\t\t\tnickName:res.userInfo.nickName\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t},\r\n\t\t\t\t\tfail: res => {\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t  })\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t}\r\n\t\t\t  }\r\n\t\t\t})\r\n\t\t},\t\r\n\t}\r\n}\r\npages/index/index.vue获取到 userInfo 便可以使用了，如果需要，还可以使用watch监听。export default {\r\n\tdata() {\r\n\t\treturn {\r\n\r\n\t\t} \r\n\t},\r\n\tonLoad(){\r\n\t\t\r\n\t},\r\n\tcomputed: {\r\n\t\tuserInfo() {\r\n\t\t\treturn this.$store.state.hasUserInfo\r\n\t\t}\r\n\t},\r\n\twatch:{\r\n\t\tuserInfo(val){\r\n\t\t\tif(val){\r\n\t \t\t \t\r\n\t \t\t}\r\n\t \t}\r\n\t},\r\n\tcreated() {\r\n\r\n\t},\r\n\tmethods: {\r\n\t\t\r\n\t}\r\n}"}
{"title": "从CSS角度来做一个模态框 ", "author": null, "pub_time": null, "content": "今天我们从CSS角度来做一个下图这种模态框。先上代码： https://developers.weixin.qq....模态框背后的背景是一个fixed定位，四个方向都为0的view，主要是怎么实现中间弹窗的垂直水平居中，这里提供两个方案。1、定位这种方案是将弹窗设置绝对定位后，左边（上边）距设为50%，就是弹窗左上角距父级左上角的距离正好是父级的宽度（高度）的50%，就是在正中间，同时使用 transform 属性，将弹窗向左（上）移动自身宽度（高度）的50%，来实现弹窗正好在水平（垂直）方向都能居中。position: absolute;\r\ntop: 50%;\r\nleft: 50%;\r\ntransform: translateX(-50%) translateY(-50%);2、flex布局这种方案更简单，只需要将父级设置为flex布局的同时设置 justify-content 和 align-items都是 center 就可以了。display: flex;\r\njustify-content: center;\r\nalign-items: center;彩蛋模态框弹出后，在父级上加上 catchtouchmove=\"ture\" 就可以阻止背后页面的上下滚动。"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": null, "pub_time": null, "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "使用 async await 封装微信小程序HTTP请求 ", "author": null, "pub_time": null, "content": "1. 编写将普通回调函数形式的方法转换为promise方法的promisic方法 1 // util.js\r\n 2 const promisic = function (func) {\r\n 3     return function (params = {}) {\r\n 4         return new Promise((resolve, reject) => {\r\n 5             const args = Object.assign(params, {\r\n 6                 success: (res) => {\r\n 7                     resolve(res)\r\n 8                 },\r\n 9                 fail: (error) => {\r\n10                     reject(error)\r\n11                 }\r\n12             })\r\n13             func(args)\r\n14         })\r\n15     }\r\n16 }\r\n17 \r\n18 export {\r\n19     promisic\r\n20 } 2. 编写Http类封装HTTP请求 1 // http.js\r\n 2 import { promisic } from \"./util\"\r\n 3 import { config } from \"../config/config\"\r\n 4 \r\n 5 /**\r\n 6  * 使用 async await 封装HTTP请求\r\n 7  */\r\n 8 class Http {\r\n 9 \r\n10     static async request({ url, method='GET', data }) {\r\n11         // 将wx.request方法转换成promise方法\r\n12         const res = await promisic(wx.request)({\r\n13             url: `${config.apiBaseUrl}${url}`,\r\n14             method,\r\n15             data,\r\n16             header: {\r\n17                 appkey: config.appkey\r\n18             }\r\n19         })\r\n20         return res.data\r\n21     }\r\n22 \r\n23 }\r\n24 \r\n25 export {\r\n26     Http\r\n27 } 3. 编写Theme业务类调用封装好的Http请求// theme.js\r\nimport { Http } from \"../utils/http\"\r\n\r\n/**\r\n * 编写主题请求业务类\r\n */\r\nclass Theme {\r\n\r\n    /**\r\n     * 获取首页主题A\r\n     */\r\n    static async getHomeLocationA() {\r\n        return await Http.request({\r\n            url: 'xx/xx/xxx',\r\n            data: {\r\n                names: 't-1'\r\n            }\r\n        })\r\n    }\r\n\r\n}\r\n\r\nexport {\r\n    Theme\r\n} 4. 在page中调用Theme业务类获取首页主题A方法 1 // home.js\r\n 2 import { Theme } from '../../model/theme'\r\n 3 \r\n 4 Page({\r\n 5 \r\n 6   data: {\r\n 7     topTheme: {}\r\n 8   },\r\n 9 \r\n10   async onLoad (options) {\r\n11     // 获取首页主题A\r\n12     const data = await Theme.getHomeLocationA()\r\n13     this.setData({\r\n14         topTheme: data[0]\r\n15     })\r\n16   }\r\n17 \r\n18 }) 附上目录结构  这样就可以愉快地使用async await形式的Http请求了，彻底摆脱各种callback方法！"}
{"title": "小程序技能进阶回忆录 - 在缺少组件化的日子里 ", "author": null, "pub_time": null, "content": "战争，信念，意志和情感，这些散发着光芒和硝烟的词汇，象一枚枚炮弹轰入我们现在的生活。历史的记忆不会被抹灭。当我们在各自项目里幸福的拷贝着官方代码 demo，在 componnets 文件夹里使用 Component方法书写一个个组件时，不要忘记，在 2018 年上半年以前，小程序是没有提供组件化方案的。当时，主要有两种解决方法，一种是 WePY 拷贝法，另一种则是 template 法。WePY 拷贝法比如有个最简单的按钮组件：<!-- components/button.wpy -->\r\n<template>\r\n  <view class=\"button\">\r\n    <button @tap=\"onTap\">点这里</button>\r\n  </view>\r\n</template>\r\n\r\n<!-- pages/index.wpy -->\r\n<template>\r\n  <view class=\"container\">\r\n    <wpy-button /> // button 组件1\r\n    <wpy-button2 /> // button 组件2\r\n  </view>\r\n</template>\r\n复制代码经过编译后结果如下：<view class=\"container\">\r\n  <view class=\"button\">\r\n    <button bindtap=\"$wpyButton$onTap\">点这里</button>\r\n  </view>\r\n  <view class=\"button\">\r\n    <button bindtap=\"$wpyButton2$onTap\">点这里</button>\r\n  </view>\r\n</view>\r\n复制代码为了方便变量隔离，所以引入到页面中的组件得单独命名：import wepy from 'wepy'\r\nimport Button from '@/components/button'\r\nexport default class Index extends wepy.page {\r\n  components = {\r\n    'wpy-button': Button,\r\n    'wpy-button2': Button\r\n  }\r\n  ...\r\n}\r\n复制代码如果多个页面引入同一组件会拷贝多份，有一些不便的地方，但也很好的解决了当时组件化缺失的问题。template 法有心的同学可能记得当初我们发了这篇文章： 微信小程序组件化解决方案wx-component ，当时主要讲了如何使用，这次讲讲技术的细节。主要利用小程序当时提供的 template 模板方法，使用方式如下：<!-- pages/template/login.wxml -->\r\n<template name=\"login\">\r\n  <view class=\"login\">这是登录组件</view>\r\n</template>\r\n复制代码<!-- pages/login/index.wxml -->\r\n<import src='../../components/login/index.wxml'/>\r\n<view class=\"login-box\">\r\n  <template is=\"login\" data=\"{{...}}\"></template>\r\n</view>\r\n复制代码由于知道这只是临时的解决方法，最终还会迁移到微信官方组件化方案。了解到微信团队正在开发，就死皮赖脸找了微信研发同学要下技术方案，以便后期迁移成本做到最低。最后微信同学不耐烦的扔给我们如下代码，并特别嘱咐 不要泄露出去 -_-：Component({\r\n  // 组件名\r\n  name: '',\r\n  // 为其他组件指定别名\r\n  using: {},\r\n  // 类似mixins，组件间代码复用\r\n  behaviors: [],\r\n  // 组件私有数据\r\n  data: {\r\n  },\r\n  // 外部传入的组件属性\r\n  propties: {\r\n  },\r\n  // 当组件被加载\r\n  attached () {\r\n  },\r\n  // 当组件被卸载\r\n  detached () {\r\n  },\r\n  // 组件私有方法\r\n  methods: {\r\n  }\r\n})\r\n复制代码一目了然，依照此文档实现一个简单的组件化方案也有了思路。如何引入组件由于没有办法在小程序全局注入 Component 方法，可以将组件代码以模块方式导出，在页面的 Page 方法里引入：// components/login/index.wxml\r\n<template name=\"login\">\r\n  <form bindsubmit=\"onLoginSubmit\">\r\n    ...\r\n    <button type=\"primary\" formType=\"submit\">{{btnText}}</button>\r\n  </form>\r\n</template>\r\n复制代码// components/login/index.js\r\nmodule.exports = {\r\n  name: 'login',\r\n  data: {\r\n    btnText: ''\r\n  }\r\n  ....\r\n}\r\n复制代码// pages/index/index.js\r\nPage({\r\n  data: {\r\n    ...\r\n  },\r\n  components: {\r\n    login: {\r\n      btnText: '开始',\r\n      onLoginCallback() { ... }\r\n    }\r\n  }\r\n})\r\n复制代码<!-- pages/index/index.wxml -->\r\n<import src='../../components/login/index.wxml'/>\r\n<view class=\"login-box\">\r\n  <template is=\"login\" data=\"{{...login}}\"></template>\r\n</view>\r\n复制代码在 Page 的传参里多了 components 属性，传入了组件名 login ，以及组件对应的属性值和方法。为了使这些新增传参生效，那势必需要对 Page 进行改造。改造 Page如何用一行代码毁掉你的小程序，在小程序根目录的 app.js 里加入这段代码即可：Page = funtion() {}\r\n复制代码这样核心的 Page 的方法就被覆盖掉了，所以利用这个“特性”，可以改造 Page 方法：// utils/wx.js\r\nvar page = function() {\r\n  // 改造代码\r\n  ...\r\n}\r\nmodule.exports = {\r\n  page\r\n}\r\n复制代码// app.js\r\nPage = require('./utils/wx').page\r\n复制代码这就完成了独一无二的自定义的小程序 Page 的方法。Component 怎么写精简了核心的代码如下：function noop() {}\r\n\r\nclass Component {\r\n  constructor (config) {\r\n    // 兼容 onLoad onUnload 的写法\r\n    config.onLoad = config.onLoad || config.attached || noop\r\n    config.onUnload = config.onUnload || config.detached || noop\r\n    this.data = config.data || {}\r\n    this.config = config\r\n    this.methods = config.methods || {}\r\n    for (let name in this.methods) {\r\n      // 为了使组件事件绑定生效，直接挂在到 this 下\r\n      this[name] = methods[name]\r\n    }\r\n  }\r\n  setData (data, deepExtend) {\r\n    let name = this.name\r\n    let parent = this.parent\r\n    let mergeData = extend(deepExtend !== false, parent.data[name], data)\r\n    let newData = {}\r\n    newData[name] = mergeData\r\n    this.data = mergeData\r\n    // 更新页面的 data\r\n    parent.setData(newData)\r\n  }\r\n  setName (name) {\r\n    this.name = name\r\n  }\r\n  setParent (parent) {\r\n    this.parent = parent\r\n  }\r\n}\r\n复制代码主要完成了三件事：配置了组件的生命周期事件 attached 和 detached绑定了组件的事件，使得 template 的 bindtap 等代码生效实现了组件的 setData 功能有个细节，为了让大家容易理解，分享到外部用 onLoad 、 onUnload 代替了 attached 、 detached ，但内部早就开始用微信命名的这两个属性名，才有了代码中的兼容写法。自定的 Page 怎么写整理了大致的核心代码如下：// 缓存下微信的 Page\r\nconst originalPage = Page\r\n// 组件生命周期\r\nconst LIFETIME_EVENT = [\r\n  'onLoad',\r\n  'onUnload'\r\n]\r\nclass MyPage {\r\n  constructor (origin) {\r\n    this.origin = origin\r\n    this.config = {}\r\n    this.children = {}\r\n    this.childrenEvents = {}\r\n\r\n    // 是否需要`components`\r\n    let components = this.components = origin.components\r\n\r\n    if (components) {\r\n      this.config.data = {}\r\n      for (let item in components) {\r\n        let props = components[item] || {}\r\n        let component = new Component(require(`../components/${item}/index`))\r\n\r\n        this.children[name] = component\r\n        // 合并组件的 data\r\n        extend(component.data, component.props)\r\n        // ...\r\n        // 合并组件的 method\r\n        for (let fnName in component.methods) {\r\n          this.config[fnName] = component.methods[fnName].bind(component)\r\n        }\r\n        // ...\r\n        let childrenEvents = this.childrenEvents[item] = {}\r\n        LIFETIME_EVENT.forEach((prop) => {\r\n          childrenEvents[item][prop] = component.config[prop]\r\n        })\r\n      }\r\n      \r\n      // 合并所有依赖组件的生命周期函数\r\n      LIFETIME_EVENT.forEach((prop) => {\r\n        this.config[prop] = () => {\r\n          for (let item in this.components) {\r\n            this.childrenEvents[item][prop].apply(this.component, arguments)\r\n          }\r\n          this.origin[prop] && this.origin[prop].apply(this, arguments)\r\n        }\r\n      })\r\n\r\n      // 把新生成的 config 传给原始的微信的 Page 方法\r\n      originalPage(this.config)\r\n    } else {\r\n      // 没有依赖组件，直接透传给微信的 Page 方法\r\n      originalPage(origin)\r\n    }\r\n\r\n  }\r\n}\r\n复制代码可能有点乱，其实就是不断 merge data 和 method 的过程。最终所有组件自定的数据和方法都被挂在到了 Page 的传参里。最后，导出自定义的 page ：// utils/wx.js\r\nconst page = function (config) {\r\n  return new MyPage(config)\r\n}\r\n\r\nmodule.exports = {\r\n  page\r\n}\r\n复制代码在 app.js 中覆盖掉原有的 Page 方法：// app.js\r\nPage = require('./utils/wx').page\r\n复制代码不完善的地方虽然满足业务了，但也是有些问题的，例如上面 MyPage 方法里的这段：for (let fnName in component.methods) {\r\n  this.config[fnName] = component.methods[fnName].bind(component)\r\n}\r\n复制代码可以看出，直接把组件内部定义的方法，挂在到 config 中去了，这就要求页面的方法和组件的方法不能重名，这是为了方便 template 可以直接绑定组件定义的事件，只能通过把组件事件转移到页面的事件方法里。也有很多其他不完善的地方，但早期通过内部约束代码规范也基本可以解决。结语这种近乎 Hack 的方式支撑了摩拜单车小程序业务大半年的时间，期间产出了大大小小十多个组件。而由于组件内部基本是按照微信官方组件化 api 书写，待官方推出组件化方案后，全部迁移过去的成本也大大减小。传送门小程序技能进阶回忆录 - 也许你并不需要小程序框架小程序技能进阶回忆录 - 在缺少组件化的日子里小程序技能进阶回忆录 - 如何自主实现数据侦听器和计算器 （待发布）小程序技能进阶回忆录 - 如何自主实现拦截器（待发布）小程序技能进阶回忆录 - globalData 的那些事儿（待发布）小程序技能进阶回忆录 - 什么时候执行 onLoad（待发布）小程序技能进阶回忆录 - 增强型的 wx.navigateBack（待发布）广告时间美团单车事业部（摩拜单车）诚招前端 / 小程序研发工程师，有兴趣可以发简历到 zhangshibing@mobike.com ）"}
{"title": "手把手教你避开组件cover-view的那些坑 ", "author": null, "pub_time": null, "content": "以下内容转载自微信开放社区腾讯位置服务官方文章《手把手教你避开组件cover-view的那些坑》作者：腾讯位置服务链接: https://developers.weixin.qq....来源：微信开放社区著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。案例背景：最近在开发城市地铁图项目，具体功能有规划路线、定位最近地铁站、以及显示整个城市的地铁网状图等功能。根据需求，在实现的时候在地铁线路图上需要添加定位按钮及线路弹框来展示位置信息以及地铁站详情信息。遇到的问题：在地铁图调研初期，原计划实现渲染方案是采用svg来绘制，但是调研后发现小程序原生API不支持svg。同时，我们在开源中找到一个svg的框架库来实现绘制，但是开发初期发现遇到很多无法实现的需求和性能问题。在对开源库的代码跟踪后，发现绘制方案也是canvas的方式，于是我们决定使用原生canvas的方案来支持地铁图。但是呢，又遇到一些问题，那么我们来看看几个具体的点：        1) view在canvas上无法正常显示。在canvas上使用view来添加图片和弹框时，发现图片以及弹框在canvas的下面，不能正常显示图片。查看文档发现canvas、map、video等原生组件使用的是native实现的，默认显示在小程序的最上层，所以就把view换成cover-view或者cover-image。使用view效果：<!-- 线路 -->\r\n<view class = \"sublines sublines-icon\">\r\n<image class = 'sublinesIcon' src = \"/static/img/ic_sublines.png\" bindtap = 'clickSublines' wx-if = \"{{lineIconShow}}\" ></ image > \r\n</view>替换成cover-view效果：<!-- 线路 -->\r\n<cover-view class = \"sublines sublines-icon\">\r\n<cover-image class = 'sublinesIcon' src = \"/static/img/ic_sublines.png\" bindtap = 'clickSublines' wx-if =\"{{lineIconShow}}\"></cover-image>\r\n</cover-view>但是使用cover-view又遇到了层级和样式的问题。2）canvas上使用cover-image添加图片，图片设置position：absolute；页面上的图片显示在canvas画线的下方，导致定位按钮不能正常使用。后来把position该换成fixed解决来层级的问题。效果如下所示：.locationIcon {\r\n    width: 3rem;\r\n    height: 3rem;\r\n    position: fixed;\r\n    bottom: 3rem;\r\n    left: 0.7rem;\r\n}3）在页面上实现一个弹框时，根据UI图需要实现一个底边线和底边小三角形。通过border给块级元素设置底边线或者css实现三角箭头，单边border设置无效。最终采用了height为1px的cover-view或者图片来代替。设置单边border效果：<!-- 起终点设置弹框 -->\r\n<cover-view class =  \"sdMark\"  style =  'top:{{tapClient.y}}px;left:{{tapClient.x}}px;'  wx-if  =  \"{{sdMarkShow}}\">\r\n    <cover-view class = 'sdMarkContent'>\r\n        <cover-view class = 'sdMarkItem' bindtap = 'clickStart'>设为起点</cover-view>\r\n        <cover-view class = 'sdMarkItem' bindtap = 'clickEnd' >设为终点</cover-view>\r\n        <cover-view class = 'sdMarkItem' bindtap = 'clickStationDetail'>站点详情</cover-view>\r\n    </cover-view>\r\n</cover-view>修改后的代码：<!-- 起终点设置弹框 -->\r\n<cover-view class = \"sdMark\" style = 'top:{{tapClient.y}}px;left:{{tapClient.x}}px;' wx-if = \"{{sdMarkShow}}\">\r\n    <cover-view class = 'sdMarkContent'>\r\n        <cover-view class = 'sdMarkItem' bindtap = 'clickStart'>设为起点</cover-view>\r\n        <cover-view class = 'line'></cover-view>\r\n        <cover-view class = 'sdMarkItem' bindtap = 'clickEnd'>设为终点</cover-view>\r\n        <cover-view class = 'line'></cover-view>\r\n        <cover-view class = 'sdMarkItem' bindtap``= 'clickStationDetail'>站点详情</cover-view>\r\n    </cover-view>\r\n    <cover-view class = \"icon\">\r\n        <cover-image class = 'icArrow' src = '/static/img/ic_arrow.png'></cover-image>\r\n    </cover-view>\r\n</cover-view>最终的效果：踩坑总结：canvas层级较高，使用cover-view或者cover-image在canvas做操作。单边border相关的操作使用图片或者块级元素来代替。查看相关API文档：cover-view相关文档：https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html欢迎体验和吐槽：\"腾讯位置服务-地铁图\"插件：https://lbs.qq.com/miniprogram_plugin/subway.html"}
{"title": "在小程序中自定义弹窗组件 ", "author": null, "pub_time": null, "content": "component\r\n{\r\n    \"component\": true\r\n}\r\n复制代码表明它是一个组件，我们称之为“子组件” 3. 注意：在组件wxss中不应使用ID选择器、属性选择器和标签名选择器。（只使用class）如何使用组件便于区分，引用子组件的页面我们称之为“父组件，” 在父组件的json里先引用子组件：{\r\n  \"usingComponents\": {\r\n    \"component-tag-name\": \"path/to/the/custom/component\"\r\n  }\r\n}\r\n复制代码父组件传值给子组件因为这个自定义的弹窗组件会应用于很多不同的页面，所以显示的弹窗标题也是不同的，这就是需要父组件给子组件自定义标题，也就是子组件的标题应该从父组件中接受到的。 子组件里： wxml<view class=\"page\">\r\n  <view>{{popupTitle}}</view>\r\n</view>\r\n复制代码jsComponent({\r\n  properties: {\r\n    // 这里定义了innerText属性，属性值可以在组件使用时指定\r\n    popupTitle: { //弹窗标题\r\n      type: String,\r\n      value: '默认值', \r\n    }\r\n  },\r\n})\r\n复制代码父组件里： wxml<popup popup-title=\"{{pagetitle}}\"/>\r\n复制代码jsdata: {\r\n    pagetitle: '我是页面标题',\r\n}\r\n复制代码. 在子组件中自定义值是以小驼峰的形式书写的，但是在父组件传的时候要以“-”连接。子组件改变父组件的值这个组件的显示和隐藏都是在父组件决定的，但是因为我这是一个全屏的弹窗，覆盖了整个屏幕，所以想要关闭弹框只能想办法在子组件的点击事件上想办法。 基本逻辑是这样的： 操作流程：打开页面- 点击弹框（弹出子组件）- 点击关闭（点击子组件关闭弹窗） 数据流程：打开页面-点击弹框（传入弹窗标题、点赞成功结果、其他参数）-点击关闭（在父组件上自定义组件，然后子组件关闭按钮监听onTap事件，点击子组件关闭按钮时，会通知父组件去改变状态）逻辑：在子组件中给要触发的元素加 bindtap = 'onTap'然后通过在method中设置onTap函数在onTap中的triggerEvent中设置要触发父组件事件的函数名称父组件接收到字组件的消息，然后触发事件具体参考：\t小程序-组件通信子组件： wxml<view class=\"hide-btn\" bindtap=\"onTap\">×</view>\r\n复制代码jsmethods: { //放自定义的方法\r\n    onTap: function () {\r\n      var myEventDetail = {} // detail对象，提供给事件监听函数\r\n      var myEventOption = {} // 触发事件的选项\r\n      console.log(`子组件：'向父组件发送通知，我要关闭弹窗'`)\r\n      this.triggerEvent('hidepopop', myEventDetail, myEventOption)\r\n    }\r\n  },\r\n复制代码父组件 wxml<popup \r\nbindhidepopop=\"hidePopop\" \r\nis-show-popup=\"{{isShowPopup}}\" \r\npopup-title=\"{{popupTitle}}\" \r\npopup-content=\"{{popupContent}}\"\r\n/>\r\n复制代码jshidePopop: function(e) {\r\n    console.log(e.detail) // 自定义组件触发事件时提供的detail对象\r\n    console.log('父组件：我接受到了子组件的关闭弹窗的通知！');\r\n    this.setData({\r\n      isShowPopup: true\r\n    })\r\n  }\r\n复制代码参考小程序-自定义组件 代码地址：\tgithub.com/AnsonZnl/wx…"}
{"title": "云开发如何实现管理员通知消息 ", "author": null, "pub_time": null, "content": "需求描述小程序目前的主要能力还都在小程序端实现，但是我们在进行开发的小程序不可能只有小程序端能力，我们也会有一些管理端能力。比如说，当用户在小程序中提交了消息以后，我们的小程序应该可以通知到小程序的管理员，以便让管理员进行下一步操作。解决方案架构说明由于小程序本身不支持长久性的消息通知能力，因此，我们可以考虑借助一些第三方的服务和能力，来完成我们自己的需求。这个需求很适合使用小程序新发布的 长期订阅消息 能力，但是目前该能力开放的类目还不足以支持我们的需要。一般而言，使用短信是我们目前到达率比较高的能力，且更为普遍的能力，其他通道的能力大多受限或不符合国情，为了确保通知信息的到达率，我们这篇文章就使用短信来完成需求。架构图示具体操作1. 开通腾讯云短信服务并获取配置信息我们想要发送短信，就需要先有一个短信服务，用于发送短信，这里我们可以使用腾讯云提供的云短信服务来发送短信。开通腾讯云短信，并创建应用首先，你需要访问 https://console.cloud.tencent... ,点击开通腾讯云·云短信。在开通完成后，点击界面中的【 添加应用 】，添加一个新的短信应用，你可以根据自己的实际情况，添加短信应用的名称和简介。获取 AppID、App Key添加完成后，点击你创建好的应用，进入到应用详情页,在应用的详情页中的应用信息栏目中，你可以找到 AppID 和 AppKey ，复制并保存这两个值，稍候我们会用到。2. 配置短信模板、短信签名开通了腾讯云短信服务以后，我们需要去创建短信模板，以及短信签名短信签名则是原来让收到短信的用户知道他所收到的短信来自于他的那一个服务，一般来说，设置为产品的品名。在腾讯云控制台中，进入到【云短信】控制台创建短信签名首先，点击【 国内短信 】，进入到短信的页面，点击【 创建签名 】，然后在弹出的窗口中输入你的签名的具体信息，比如这里我就是以公众号【程序百晓生】来创建签名。签名创建完成后，你需要等待腾讯云官方的审核，审核通过以后，你添加的签名才可以被使用。创建短信模板创建完签名，你需要创建一个短信的正文模板，用于发送短信。输入模板名称、短信类型，然后选择标准模板中的模板，这里我们选择“您有新的{1}订单，请注意查收！”这个模板。除了使用标准模板，你也可以自己编写一个模板，为了方便文章撰写，这里使用标准模板。然后点击提交，等待审核就可以了。3.编写云函数发送短信在完成了基础的配置后，我们在微信开发者工具中实现一个云函数，用于调用腾讯云的短信服务，实现具体的通知。首先，我们创建一个新的云函数，名为 notifyAdmin ，意为用于通知管理员的云函数。然后，选择我们刚刚创建的 notifyAdmin 云函数，在函数上右击，选择【在终端中打开】，进入到控制台，并输入如下命令，安装所需的短信 SDK。npm install --save sms-node-sdk然后，修改云函数的 index.js ，加入如下代码// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\nconst {\r\n  SmsClient\r\n} = require('sms-node-sdk');\r\n\r\n\r\nconst AppID = 1400286810;  // SDK AppID是1400开头\r\n\r\n// 短信应用SDK AppKey ，替换为你自己的 AppKey\r\nconst AppKey = 'xxxx';\r\n\r\n// 需要发送短信的手机号码\r\nconst phoneNumber = '10000000';\r\n\r\n// 短信模板ID，需要在短信应用中申请\r\nconst templId = 476457;\r\n// 签名，替换为你自己申请的签名\r\nconst smsSign = '程序百晓生';\r\n\r\n// 实例化smsClient\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  let orderId = event.orderId;\r\n  let smsClient = new SmsClient({ AppID, AppKey });\r\n  return await smsClient.init({\r\n    action: 'SmsSingleSendTemplate',\r\n    data: {\r\n      nationCode: '86',\r\n      phoneNumber,\r\n      templId: templId,\r\n      params: [orderId],\r\n      sign: smsSign // 签名参数未提供或者为空时，会使用默认签名发送短信\r\n    }\r\n  })\r\n}完成代码的修改后，就可以部署你的云函数了，右键你的云函数，选择【上传并部署云函数：云端安装依赖】4. 在小程序端触发短信在前面我们提到，在一些特定的场景下，我们希望用户的操作可以给管理员发送消息通知。在具体的实现的时候，我们可以根据自己的实际业务需求，来设定我们的通知发送的条件，比如说，在用户支付成功后发送消息，则相关代码如下：let orderId = 'this is a orderId';\r\nwx.requestPayment({\r\n    success:res => {\r\n        console.log(\"User Payment Success\");\r\n        // 调用云函数发送短信\r\n        wx.cloud.callFunction({\r\n            name:\"notifyAdmin\",\r\n            data:{\r\n                orderId: orderId\r\n            }\r\n        });\r\n    }\r\n})总结经过本次的分享，我们了解到了如何借助短信服务，实现云开发的后台通知能力，实际上，除了短信服务，你还可以借助一些其他的工具，比如邮件、企业微信机器人等能力，实现后台管理信息的推送。明天，我们将分享 如何借助通过微信发送订单消息 。"}
{"title": "捕获web与小程序JS异常的方法 ", "author": null, "pub_time": null, "content": "前段时间，我们发现小程序异步代码里的错误没有上报到异常监控平台，经过排查这部分小程序没法直接监听到，需要我们手动上报。再者，开发过程中，异常处理一直是不太受重视且容易遗漏的模块。本文总结了JS异常的类型及捕获方法，最后针对小程序给出错误处理经验。JS异常分类Error：常规异常，一般为用户自定义的异常，如 new Error(\"error message\")，这类自定义的错误用来统计异常数据，直接上报即可；RangeError：数值溢出越界异常，当 Number 类型变量超过指定的范围，如var pi = 3.14159;  pi.toFixed(100000);d（toFixed()方法参数只能接受 0~100） ；ReferenceError：引用异常，当不存在的变量被使用的时候，这类错误一般在编码检查阶段就会暴露；SyntaxError：语法错误，作为解释型语言的 JavaScript 只有到执行的时候才能识别出语法错误，这类错误在编码检查和构建阶段就会暴露；TypeError：类型错误，当调用不存在的对象方法或对象不存在时，例如：var foo = {}; foo.bar();为了避免这类错误出现，可使用防御式编程，但如若数据有误则应抛出异常；URIError：encodeURI() 和 decodeURI() 方法参数不正确抛出的异常，例如：decodeURIComponent(\"%\");EvalError：eval() 方法参数不正确抛出的异常；Web端对异常的捕获能力了解了异常的分类后，我们还需要知道浏览器如何捕获到这些异常。1）try-catchJavaScript 里有 try-catch 语法块，可用于异常捕获处理。try-catch 可以成功捕获大部分错误，但对于 SyntaxError 语法错误 和 异步代码中的错误，则无法捕获。例如：SyntaxError 语法错误try {\r\n    var p = \r\n} catch(e) { \r\n    console.log('caught error: ', e.message)\r\n}\r\n\r\n// 输出：Uncaught SyntaxError: Unexpected token '}'复制代码例如：异步代码中的错误try {\r\n    setTimeout(function() {\r\n        var p = error + 1\r\n    }, 0)\r\n} catch(e) {\r\n    console.log('caught error:', e.message)\r\n}\r\n\r\n// 输出：Uncaught ReferenceError: error is not defined复制代码2）error 事件try-catch 针对我们预感到可能会有问题的代码，捕获异常进行处理，而对于一些我们未知的错误，可以使用 window 对象的 error 事件进行监听。error 事件可以捕获到同步或异步（非 Promise ）代码中的非语法错误。例如：异步代码中的错误window.addEventListener('error', e => {\r\n  console.log('caught error', e.message);\r\n  e.preventDefault();\r\n});\r\nsetTimeout(function() {\r\n    var p = error + 1\r\n}, 0)\r\n\r\n// 输出：caught error Uncaught ReferenceError: error is not defined复制代码需要注意的是：e.preventDefault() 在 error 监听事件中调用，可以阻止报告异常给浏览器，别让浏览器默认地在控制台输出错误。另外，文档中也提到关于资源加载失败的错误：When a resource (such as an <img> or <script>) fails to load, an error event using interface Event is fired at the element that initiated the load, and the onerror() handler on the element is invoked. These error events do not bubble up to window, but (at least in Firefox) can be handled with a window.addEventListener configured with useCapture set to True.对于图片或脚本资源加载失败，这类错误不会冒泡给 window，但可以在捕获阶段进行处理，即addEventListener 最后一个参数置为 true：window.addEventListener('error', e => {\r\n    console.log('资源加载失败');\r\n}, true)复制代码3）unhandledRejection 与 rejectionhandled 事件error 事件可以捕获到非 Promise 的异步错误，而针对 Promise，window对象有专门的事件来处理这类错误。当异步错误没被 catch 住时，触发 unhandledRejection 事件：window.addEventListener('unhandledrejection', e => {\r\n    console.log('caught unhandledrejection', e.reason);\r\n    e.preventDefault();\r\n})\r\nvar p = new Promise(function(resolve, reject) {\r\n    tp = error + 1\r\n})\r\n\r\n// 输出：caught unhandledrejection ReferenceError: error is not defined复制代码而当异步错误一开始未被 catch 住，过后才被 catch 的情况，会先触发 unhandledRejection 事件，当被 catch 的时候，会触发 rejectionhandled 事件：window.addEventListener('unhandledrejection', e => {\r\n    console.log('caught unhandledrejection', e.reason);\r\n    e.preventDefault();\r\n})\r\nwindow.addEventListener('rejectionhandled', e => {\r\n    console.log('caught rejectionhandled', e.reason);\r\n    e.preventDefault();\r\n})\r\nvar p = new Promise(function(resolve, reject) {\r\n    tp = error + 1\r\n})\r\nsetTimeout(() => {\r\n    p.catch(e => console.log('catch', e.message))\r\n}, 1000)\r\n\r\n// 输出：\r\n// caught unhandledrejection ReferenceError: error is not defined\r\n// （1s后）\r\n// catch error is not defined\r\n// caught rejectionhandled ReferenceError: error is not defined复制代码也就是说未处理的异常增加时会触发 unhandledRejection，而未处理的异常（被处理后）减少时会触发 rejectionhandled，这在上报异常中可以避免上报那些已经被处理过的异常。关于兼容性，截止至本文成稿，移动端的支持程度还是可以的，iOS主流版本 和 Chrome 都支持：（图来源：unhandledrejection/rejectionhandled events，caniuse.com/#search=unh…）小程序端对异常的捕获能力小程序的 App 对象中有 onError 方法，相当于 web 端的 error 事件，可以捕获到同步或异步（非 Promise ）代码中的非语法错误。而对于 Promise，小程序并没有如 window 对象中的 unhandledRejection 与 rejectionhandled 事件，无法像 web 端那样统一处理异常。不过，既然都是 Promise 相关的错误，那么，我们可以改写或覆盖 Promise 对象，将其进行封装把所有错误都 catch 住也就可以了。推荐 promise-polyfill 这个轻量级的 promise 实现包，其中提供了 _unhandledRejectionFn 方法，用于捕获那些未被处理的 Promise 异常。import Promise from 'promise-polyfill';\r\nPromise._unhandledRejectionFn = function(rejectError) {\r\n    // 处理异常或上报\r\n}\r\n复制代码总结关于JS的异常总结已经差不多了，之前一直觉得这部分知识不够系统，一来自己重视程度不够，二来也是知识点不多但都较零散。经过这段时间收集资料，捋清思路，编码实现还算有所收获，便总结成文，若有不尽不祥不对之处烦请各位读者多多指点。参考文献Exceptional Exception Handling in JavaScript前端代码异常监控实战GlobalEventHandlers.onerrorPromise rejection events in Using Promisespromise-polyfill"}
